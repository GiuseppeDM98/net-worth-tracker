import { NextRequest, NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase/admin';
import { Timestamp } from 'firebase-admin/firestore';
import { scrapeDividendsByIsin } from '@/lib/services/borsaItalianaScraperService';
import { createDividend, isDuplicateDividend } from '@/lib/services/dividendService';
import { createExpenseFromDividend } from '@/lib/services/dividendIncomeService';
import { DividendFormData } from '@/types/dividend';
import { isDateOnOrAfter } from '@/lib/utils/dateHelpers';
import { Asset } from '@/types/assets';

/**
 * GET /api/cron/daily-dividend-processing
 * Vercel cron job that processes dividends with payment date = today
 * Creates expense entries for paid dividends if user has configured dividend income category
 * Runs daily at 00:00 UTC
 */
export async function GET(request: NextRequest) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    console.log('Starting daily dividend processing cron job...');

    // Get all users
    const usersRef = adminDb.collection('users');
    const usersSnapshot = await usersRef.get();

    if (usersSnapshot.empty) {
      return NextResponse.json({
        success: true,
        message: 'No users found',
        processedCount: 0,
        errorCount: 0,
        timestamp: new Date().toISOString(),
      });
    }

    // ==================== PHASE 1: AUTOMATIC DIVIDEND SCRAPING ====================
    console.log('Phase 1: Starting automatic dividend scraping for recent dividends...');

    let scrapedAssetsCount = 0;
    let scrapingErrorsCount = 0;
    let newDividendsCount = 0;

    // Define lookback window (60 days)
    const sixtyDaysAgo = new Date();
    sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);

    for (const userDoc of usersSnapshot.docs) {
      const userId = userDoc.id;

      try {
        // Get user's equity assets with ISIN
        const assetsRef = adminDb.collection('assets');
        const assetsQuery = assetsRef
          .where('userId', '==', userId)
          .where('assetClass', '==', 'equity');

        const assetsSnapshot = await assetsQuery.get();

        // Filter for assets with non-empty ISIN
        const assetsWithIsin = assetsSnapshot.docs
          .map(doc => ({
            id: doc.id,
            ...doc.data(),
            createdAt: doc.data().createdAt?.toDate() || new Date(),
          } as Asset))
          .filter((asset) => asset.isin && asset.isin.trim() !== '');

        if (assetsWithIsin.length === 0) {
          continue;
        }

        console.log(`User ${userId}: Found ${assetsWithIsin.length} equity assets with ISIN`);

        // Scrape dividends for each asset
        for (const asset of assetsWithIsin) {
          try {
            console.log(`Scraping dividends for ${asset.ticker} (ISIN: ${asset.isin}, Type: ${asset.type})`);

            const scrapedDividends = await scrapeDividendsByIsin(asset.isin!, asset.type);

            if (scrapedDividends.length === 0) {
              continue;
            }

            // Filter dividends:
            // 1. Ex-date within last 60 days
            // 2. Ex-date on or after asset creation
            const relevantDividends = scrapedDividends.filter((div) => {
              return div.exDate >= sixtyDaysAgo && isDateOnOrAfter(div.exDate, asset.createdAt);
            });

            console.log(`Found ${scrapedDividends.length} total, ${relevantDividends.length} relevant dividends for ${asset.ticker}`);

            // Create dividend entries
            for (const scrapedDiv of relevantDividends) {
              try {
                // Check for duplicates
                const isDuplicate = await isDuplicateDividend(userId, asset.id, scrapedDiv.exDate);

                if (isDuplicate) {
                  continue;
                }

                // Calculate amounts
                const grossAmount = scrapedDiv.dividendPerShare * asset.quantity;
                const taxAmount = grossAmount * 0.26; // Italian withholding tax
                const netAmount = grossAmount - taxAmount;

                // Create dividend data
                const dividendData: DividendFormData = {
                  assetId: asset.id,
                  exDate: scrapedDiv.exDate,
                  paymentDate: scrapedDiv.paymentDate,
                  dividendPerShare: scrapedDiv.dividendPerShare,
                  quantity: asset.quantity,
                  grossAmount,
                  taxAmount,
                  netAmount,
                  currency: scrapedDiv.currency,
                  dividendType: scrapedDiv.dividendType,
                  isAutoGenerated: true,
                };

                // Create dividend entry
                await createDividend(
                  userId,
                  dividendData,
                  asset.ticker,
                  asset.name,
                  asset.isin!,
                  true // isAutoGenerated
                );

                newDividendsCount++;
                console.log(`Created dividend: ${asset.ticker} - ${scrapedDiv.dividendPerShare} ${scrapedDiv.currency} on ${scrapedDiv.exDate.toLocaleDateString('it-IT')}`);
              } catch (dividendError) {
                console.error(`Error creating dividend for ${asset.ticker}:`, dividendError);
                // Continue with next dividend
              }
            }

            scrapedAssetsCount++;
          } catch (assetError) {
            console.error(`Error scraping dividends for asset ${asset.ticker}:`, assetError);
            scrapingErrorsCount++;
          }
        }
      } catch (userError) {
        console.error(`Error processing user ${userId} for dividend scraping:`, userError);
        scrapingErrorsCount++;
      }
    }

    console.log(`Phase 1 completed: Scraped ${scrapedAssetsCount} assets, created ${newDividendsCount} new dividends, ${scrapingErrorsCount} errors`);

    // ==================== PHASE 2: EXPENSE CREATION FOR PAID DIVIDENDS ====================
    console.log('Phase 2: Starting expense creation for paid dividends...');

    // Calculate today's date range (00:00 to 23:59)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayEnd = new Date(today);
    todayEnd.setHours(23, 59, 59, 999);

    const todayStartTimestamp = Timestamp.fromDate(today);
    const todayEndTimestamp = Timestamp.fromDate(todayEnd);

    let processedCount = 0;
    let errorCount = 0;
    const processedDividends: any[] = [];
    const errors: any[] = [];

    // Process each user
    for (const userDoc of usersSnapshot.docs) {
      const userId = userDoc.id;

      try {
        // Get user settings
        const settingsRef = adminDb.collection('assetAllocationTargets').doc(userId);
        const settingsDoc = await settingsRef.get();

        if (!settingsDoc.exists) {
          console.log(`No settings found for user ${userId}, skipping`);
          continue;
        }

        const settings = settingsDoc.data();
        const dividendIncomeCategoryId = settings?.dividendIncomeCategoryId;

        if (!dividendIncomeCategoryId) {
          console.log(`No dividend income category configured for user ${userId}, skipping`);
          continue;
        }

        // Get category details
        const categoryRef = adminDb.collection('expenseCategories').doc(dividendIncomeCategoryId);
        const categoryDoc = await categoryRef.get();

        if (!categoryDoc.exists) {
          console.log(`Category ${dividendIncomeCategoryId} not found for user ${userId}, skipping`);
          continue;
        }

        const category = categoryDoc.data();
        const categoryName = category?.name || 'Dividendi';

        // Get subcategory details if configured
        let subCategoryName: string | undefined;
        if (settings.dividendIncomeSubCategoryId) {
          const subCategories = category?.subCategories || [];
          const subCategory = subCategories.find(
            (sub: any) => sub.id === settings.dividendIncomeSubCategoryId
          );
          if (subCategory) {
            subCategoryName = subCategory.name;
          }
        }

        // Query dividends with payment date = today AND no linked expense
        const dividendsRef = adminDb.collection('dividends');
        const dividendsQuery = dividendsRef
          .where('userId', '==', userId)
          .where('paymentDate', '>=', todayStartTimestamp)
          .where('paymentDate', '<=', todayEndTimestamp);

        const dividendsSnapshot = await dividendsQuery.get();

        if (dividendsSnapshot.empty) {
          console.log(`No dividends due today for user ${userId}`);
          continue;
        }

        console.log(`Found ${dividendsSnapshot.size} dividends due today for user ${userId}`);

        // Process each dividend
        for (const dividendDoc of dividendsSnapshot.docs) {
          const dividend = dividendDoc.data();
          const dividendId = dividendDoc.id;

          // Skip if already has linked expense
          if (dividend.expenseId) {
            console.log(`Dividend ${dividendId} already has linked expense, skipping`);
            continue;
          }

          try {
            // Transform Firestore data to Dividend type
            const dividendData = {
              id: dividendId,
              userId,
              assetId: dividend.assetId,
              assetTicker: dividend.assetTicker,
              assetName: dividend.assetName,
              isin: dividend.isin,
              exDate: dividend.exDate?.toDate(),
              paymentDate: dividend.paymentDate?.toDate(),
              dividendPerShare: dividend.dividendPerShare,
              quantity: dividend.quantity,
              grossAmount: dividend.grossAmount,
              taxAmount: dividend.taxAmount,
              netAmount: dividend.netAmount,
              currency: dividend.currency,
              dividendType: dividend.dividendType,
              grossAmountEur: dividend.grossAmountEur,
              taxAmountEur: dividend.taxAmountEur,
              netAmountEur: dividend.netAmountEur,
              exchangeRate: dividend.exchangeRate,
              notes: dividend.notes,
              isAutoGenerated: dividend.isAutoGenerated,
              createdAt: dividend.createdAt?.toDate(),
              updatedAt: dividend.updatedAt?.toDate(),
            };

            // Use dividendIncomeService for EUR-aware expense creation
            const expenseId = await createExpenseFromDividend(
              dividendData,
              dividendIncomeCategoryId,
              categoryName,
              settings.dividendIncomeSubCategoryId,
              subCategoryName
            );

            processedCount++;
            processedDividends.push({
              userId,
              dividendId,
              expenseId,
              amount: dividendData.netAmountEur || dividendData.netAmount, // Show EUR if available
              asset: dividend.assetTicker,
            });

            console.log(`Created expense ${expenseId} for dividend ${dividendId} (${dividend.assetTicker})`);
          } catch (dividendError) {
            console.error(`Error processing dividend ${dividendId}:`, dividendError);
            errorCount++;
            errors.push({
              userId,
              dividendId,
              error: (dividendError as Error).message,
            });
          }
        }
      } catch (userError) {
        console.error(`Error processing user ${userId}:`, userError);
        errorCount++;
        errors.push({
          userId,
          error: (userError as Error).message,
        });
      }
    }

    console.log(`Daily dividend processing completed: ${processedCount} expenses created, ${errorCount} errors`);
    console.log(`Total summary: ${scrapedAssetsCount} assets scraped, ${newDividendsCount} new dividends, ${processedCount} expense entries`);

    return NextResponse.json({
      success: true,
      message: 'Daily dividend processing job completed',
      timestamp: new Date().toISOString(),
      scraping: {
        assetsScraped: scrapedAssetsCount,
        newDividends: newDividendsCount,
        errors: scrapingErrorsCount,
      },
      expenseCreation: {
        processedCount,
        errorCount,
        processedDividends,
        errors,
      },
    });
  } catch (error) {
    console.error('Error in daily dividend processing cron job:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to execute daily dividend processing job',
        details: (error as Error).message,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    );
  }
}
