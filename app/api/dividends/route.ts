import { NextRequest, NextResponse } from 'next/server';
import {
  getAllDividends,
  getDividendsByAsset,
  getDividendsByDateRange,
  createDividend,
} from '@/lib/services/dividendService';
import { adminDb } from '@/lib/firebase/admin';
import { createExpenseFromDividend } from '@/lib/services/dividendIncomeService';
import { DividendFormData } from '@/types/dividend';
import { Asset } from '@/types/assets';
import { ExpenseCategory } from '@/types/expenses';

/**
 * GET /api/dividends
 *
 * Flexible dividend query endpoint with multiple filter modes
 *
 * Query Modes (mutually exclusive):
 *   1. By asset:     ?userId=X&assetId=Y
 *   2. By date:      ?userId=X&startDate=2024-01-01&endDate=2024-12-31
 *   3. All user:     ?userId=X
 *
 * Query Parameters:
 *   @param userId - Required. User ID for security filtering
 *   @param assetId - Optional. Returns dividends for specific asset
 *   @param startDate - Optional. ISO date string (requires endDate)
 *   @param endDate - Optional. ISO date string (requires startDate)
 *
 * Response:
 *   {
 *     success: boolean,
 *     dividends: Dividend[],
 *     count: number
 *   }
 *
 * Security: Uses Admin SDK - must verify userId ownership at call site
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const userId = searchParams.get('userId');
    const assetId = searchParams.get('assetId');
    const startDateStr = searchParams.get('startDate');
    const endDateStr = searchParams.get('endDate');

    if (!userId) {
      return NextResponse.json(
        { error: 'User ID is required' },
        { status: 400 }
      );
    }

    let dividends;

    // Filter by asset if provided
    if (assetId) {
      dividends = await getDividendsByAsset(userId, assetId);
    }
    // Filter by date range if provided
    else if (startDateStr && endDateStr) {
      const startDate = new Date(startDateStr);
      const endDate = new Date(endDateStr);

      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
        return NextResponse.json(
          { error: 'Invalid date format' },
          { status: 400 }
        );
      }

      dividends = await getDividendsByDateRange(userId, startDate, endDate);
    }
    // Otherwise, get all dividends
    else {
      dividends = await getAllDividends(userId);
    }

    return NextResponse.json({
      success: true,
      dividends,
      count: dividends.length,
    });
  } catch (error) {
    console.error('Error fetching dividends:', error);
    return NextResponse.json(
      { error: 'Failed to fetch dividends', details: (error as Error).message },
      { status: 500 }
    );
  }
}

/**
 * POST /api/dividends
 *
 * Create manual dividend entry with optional automatic expense creation
 *
 * Request Body:
 *   {
 *     userId: string,
 *     dividendData: DividendFormData {
 *       assetId: string,
 *       exDate: Date,
 *       paymentDate: Date,
 *       dividendPerShare: number,
 *       quantity: number,
 *       grossAmount: number,
 *       taxAmount: number,
 *       netAmount: number,
 *       currency: string,
 *       dividendType: string,
 *       notes?: string
 *     }
 *   }
 *
 * Automatic Expense Creation:
 *   If paymentDate <= today AND user has dividendIncomeCategoryId configured:
 *     - Creates linked expense in cashflow
 *     - Uses EUR-converted amount if dividend.currency !== 'EUR'
 *     - Sets dividend.expenseId to link the records
 *
 * Response:
 *   {
 *     success: boolean,
 *     id: string,               // Created dividend ID
 *     expenseId?: string,       // Created expense ID (if applicable)
 *     message: string
 *   }
 *
 * Related:
 *   - dividends/scrape/route.ts: Automated scraping (isAutoGenerated=true)
 *   - cron/daily-dividend-processing/route.ts: Scheduled processing
 *   - dividendIncomeService.ts: Expense creation logic
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, dividendData } = body as {
      userId: string;
      dividendData: DividendFormData;
    };

    // Validate required fields
    if (!userId || !dividendData) {
      return NextResponse.json(
        { error: 'userId and dividendData are required' },
        { status: 400 }
      );
    }

    if (!dividendData.assetId) {
      return NextResponse.json(
        { error: 'assetId is required in dividendData' },
        { status: 400 }
      );
    }

    // Fetch asset to get ticker, name, and ISIN using Admin SDK
    const assetDoc = await adminDb
      .collection('assets')
      .doc(dividendData.assetId)
      .get();

    if (!assetDoc.exists) {
      return NextResponse.json(
        { error: 'Asset not found' },
        { status: 404 }
      );
    }

    const assetData = assetDoc.data() as Asset;
    const asset = {
      ...assetData,
      id: assetDoc.id,
    };

    // Security: Verify asset ownership before creating dividend
    //
    // Why critical:
    //   - Admin SDK bypasses Firestore security rules
    //   - Without this check, user could create dividends for ANY asset
    //   - Example attack: Create dividend for another user's high-value asset
    //
    // This manual verification is required for all Admin SDK operations
    // that don't inherently filter by userId
    if (asset.userId !== userId) {
      return NextResponse.json(
        { error: 'Asset does not belong to user' },
        { status: 403 }
      );
    }

    // Create dividend entry
    const dividendId = await createDividend(
      userId,
      dividendData,
      asset.ticker,
      asset.name,
      asset.isin,
      false // isAutoGenerated = false (manual entry)
    );

    // ========== Conditional Expense Creation ==========
    //
    // Design Decision: Create expense immediately if dividend already paid
    //
    // Logic:
    //   IF paymentDate <= today:
    //     - User likely wants expense in cashflow right away
    //     - Historical dividend entry (back-filling data)
    //   ELSE:
    //     - Future dividend (tracking expected income)
    //     - Expense will be created by daily cron job on payment date
    //
    // This dual-path approach ensures:
    //   1. Manual historical entries: Immediate cashflow impact
    //   2. Future dividends: Automated processing on payment date
    //   3. Consistent behavior with scraping workflow
    //
    // Alternative considered: Always defer to cron
    //   Rejected because users expect immediate cashflow updates
    //   when manually entering historical dividends
    const paymentDate = dividendData.paymentDate;
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    let expenseId: string | undefined;

    if (paymentDate <= today) {
      // Get user settings to check if dividend income category is configured using Admin SDK
      const settingsDoc = await adminDb
        .collection('assetAllocationTargets')
        .doc(userId)
        .get();

      const settings = settingsDoc.exists ? settingsDoc.data() : null;

      if (settings?.dividendIncomeCategoryId) {
        try {
          // Get category details using Admin SDK
          const categoryDoc = await adminDb
            .collection('expenseCategories')
            .doc(settings.dividendIncomeCategoryId)
            .get();

          if (categoryDoc.exists) {
            const categoryData = categoryDoc.data() as ExpenseCategory;
            const category = {
              ...categoryData,
              id: categoryDoc.id,
            };

            // Get subcategory name if configured
            let subCategoryName: string | undefined;
            if (settings.dividendIncomeSubCategoryId) {
              const subCategory = category.subCategories?.find(
                (sub: any) => sub.id === settings.dividendIncomeSubCategoryId
              );
              subCategoryName = subCategory?.name;
            }

            // Get the created dividend to pass to expense service
            const { getDividendById } = await import('@/lib/services/dividendService');
            const dividend = await getDividendById(dividendId);

            if (dividend) {
              expenseId = await createExpenseFromDividend(
                dividend,
                settings.dividendIncomeCategoryId,
                category.name,
                settings.dividendIncomeSubCategoryId,
                subCategoryName
              );
            }
          }
        } catch (expenseError) {
          console.error('Error creating expense from dividend:', expenseError);
          // Non-critical: Dividend creation succeeds even if expense fails
          //
          // Rationale:
          //   - Dividend is the primary operation (must succeed)
          //   - Expense is secondary feature (nice-to-have)
          //   - User can manually sync expenses later via UI
          //   - Prevents expense service failures from blocking dividend tracking
        }
      }
    }

    return NextResponse.json({
      success: true,
      id: dividendId,
      expenseId,
      message: 'Dividend created successfully',
    });
  } catch (error) {
    console.error('Error creating dividend:', error);
    return NextResponse.json(
      { error: 'Failed to create dividend', details: (error as Error).message },
      { status: 500 }
    );
  }
}
